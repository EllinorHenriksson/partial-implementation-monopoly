# Reflection on my Intended Design

My design is missing the Game class. Actually I had included a Game class initially, but after consideration I removed it and let the Board class keep everything together (i.e. have all the associations to the dice, the tiles, the players, the console and the bank). The reason why I chose to remove the Game class was that if I were to keep it, I couldn't come up with any other purpose for the Board class than to have accociations to the tiles. After seeing your suggestion of the design, my suspicion that having both a Game and a Board class would be a better option was confirmed.

My design is also missing the HumanPlayer class, and has no Player interface, compared to yours. I had no intention of including a computer player in that first state of the design, but realise now as I go back and read the instructions for assignment 2 that I should have prepared for it to be part of the game in the future. In my design I only have a Player class, but if I were to go back and redo my design I would choose to implement a Player super class instead of an interface, as most methods would have the same signatures and implementation for both the HumanPlayer and ComputerPlayer class.

I have an additional class compared to your design - the Bank class. The idea of that class was that in Monopoly, the Bank is a central part of the game that hands out money to the players and recieves money from the players. It felt intuitional that if it would be possible for a Player class instance to pay other players, it should also be posssible to pay the bank. Vice versa, the bank should be able to hand out money to the players. Taking future scenarios into account, the Bank is also responsible for holding buildings (houses and hotels) and selling them to players. As the number of houses and hotels are restricted (i.e. you can't buy any if there are no left), one purpose for the Bank class could be to keep count of them.

The naming of the classes is very similar in my intended design and the suggested design. There are only slight differences, for example I named the tile subclasses StartTile, PropertyTile and FreeTile to make it clear that they were tiles. As for the dice class I named it Die since it can only be interpreted as the singular form of dice (however the word die also has a completely different meaning, so you could argue that either option - Die or Dice - would be best). Classes are named with camel casing with an initial capital letter. The name should be a noun that is representative for the class and the attributes and operations that it holds.

Regarding the relations between the classes they differ somewhat between the designs. I chose to let Board have an association to Tile (40 tiles), with the idea that 40 tiles would be stored in an ArrayList. In the suggested design the association is from board to Start (1 start), and from there there are two associations to the Start class itself (1 next, 1 prev), as the idea is to implement a circuar double linked list. Another difference is that I chose to keep track of the players by giving the Player class the attribute position, which would correspond to the index in the ArrayList of tiles for the specific tile that the player is currently on. In the suggested design this is achieved by creating an association from HumanPlayer to Tile (1 currentTile). In my design, there is a two-way association between Player and PropertyTile (0..1 owner, 0..* properties), but in the intended design the association is only from Property to Player (0..1 owner). My idea was that in future scenarios the association from Player to PropertyTile would facilitate calculating the winner of the game as properties are counted as well as credits, as are the buildings on the properties. In the intended design there is a dependency from ConsoleUI to Player. However, in my design Player is not used by Console, but instead strings of the players' names are passed as arguments to the Console methods.

In my design I mainly use association/dependency to connect the objects, but there are two places where I've instead used some form of ID connection. The first is in Player where I use the attribute position to keep track of what tile the player is currently on. I realize it would be a better idea to instead create an association from Player to Tile (i.e. currentTile 1) to make this clearer. The second ID-like connection is in Console where strings with the players' names are passed as arguments. Instead I could have created a dependency from Console to Player and pass Player objects to the Console methods instead of just the names.

I think I managed to spread the code/behaviours between classes, although initially I tended to place monst of the behaviours in the Board class.

The object diagrams differ in that in my design, there is no link between Boris:Player and PropertyTile (AbbeyRoad), since I used a form of ID connection (as mentioned above). Nor is there a link between Boris:Player and console:Console, for the same reason. Instead there is a link between Boris:Player and :Board, and between console:Console and :Board. In my design there is only one Tile object present, as I chose to implement the association from Board to Tile as an ArrayList and not a circular double linked list. There is also a Bank object as well as a second Player object for examplification (since the game needs at least 2 players to be played). The Board object somewhat fills the roll of the Game object in my design compared to the suggested design.

Regarding the sequence diagram there are many differences between mine and the suggested design. One big difference is that in my design :Board calls itself with makeMove(Boris:Player), which assemblies all other method calls to make the sequence go through. In the suggested design this is handled by a method call to Boris - yourTurn(d1:Dice, d2:Dice). Same goes for when Boris is actually moved, in my case this is handled by a call to the method movePlayer(Boris:Player, sum:Integer) on the Board object, while in the suggested design it is handled by the method call move(3) on Boris:HumanPlayer. In hindsight I agree that it makes more sense to let the player hold the behaviour of moving instead of letting the Board object move the player. An other major difference is what happens afterwards: since I keep track of the position with indexes and not associations to the current Tile object I call methods on Boris:Player to move forward. The idea is that when this is done, the tiles that are stept on are checked to see if something should happen. For example if the player passes the start tile (index 0 in the array list of tiles) she recieves 200 credits from the bank. In the suggested design methods are insted called on the tiles. 

I think I made a pretty good job in the first design as I managed to include allmost all classes and important relations. However, I could have created associations or dependencies instead of id connections between Player and Tile regarding the position of the player. I also didn't prepare for a computer player, but would have had done it by adding a super Player class. Lastly, I could have let the Player class handle the player's moves, instead of the Board class. However, as this is my first UML design ever, I'm satisfied with my effort, but I will need more training. The most important thing I learned from this exercise was that it truly is a dynamic process, and the design will most likely change alongside developing the program as it is quit difficult - even though you try hard - to picture how everything will operate in the end. Having a first design sketch to glance at gives you a good starting point though, as you'll know which classes to focus on.